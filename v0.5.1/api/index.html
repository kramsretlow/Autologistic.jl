<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Autologistic.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Autologistic.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../Background/">Background</a></li><li><a class="tocitem" href="../Design/">Design of the Package</a></li><li><a class="tocitem" href="../BasicUsage/">Basic Usage</a></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Types-and-Constructors"><span>Types and Constructors</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kramsretlow/Autologistic.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Autologistic.ALRsimple"><code>Autologistic.ALRsimple</code></a></li><li><a href="#Autologistic.ALfit"><code>Autologistic.ALfit</code></a></li><li><a href="#Autologistic.ALfull"><code>Autologistic.ALfull</code></a></li><li><a href="#Autologistic.ALsimple"><code>Autologistic.ALsimple</code></a></li><li><a href="#Autologistic.AbstractAutologisticModel"><code>Autologistic.AbstractAutologisticModel</code></a></li><li><a href="#Autologistic.AbstractPairwiseParameter"><code>Autologistic.AbstractPairwiseParameter</code></a></li><li><a href="#Autologistic.AbstractUnaryParameter"><code>Autologistic.AbstractUnaryParameter</code></a></li><li><a href="#Autologistic.CenteringKinds"><code>Autologistic.CenteringKinds</code></a></li><li><a href="#Autologistic.Float1D2D"><code>Autologistic.Float1D2D</code></a></li><li><a href="#Autologistic.Float2D3D"><code>Autologistic.Float2D3D</code></a></li><li><a href="#Autologistic.FullPairwise"><code>Autologistic.FullPairwise</code></a></li><li><a href="#Autologistic.FullUnary"><code>Autologistic.FullUnary</code></a></li><li><a href="#Autologistic.LinPredUnary"><code>Autologistic.LinPredUnary</code></a></li><li><a href="#Autologistic.SamplingMethods"><code>Autologistic.SamplingMethods</code></a></li><li><a href="#Autologistic.SimplePairwise"><code>Autologistic.SimplePairwise</code></a></li><li><a href="#Autologistic.SpatialCoordinates"><code>Autologistic.SpatialCoordinates</code></a></li><li><a href="#Autologistic.VecOrMat"><code>Autologistic.VecOrMat</code></a></li><li><a href="#Autologistic.addboot!-Tuple{ALfit, Array{Float64, 3}, Matrix{Float64}, Vector{Bool}}"><code>Autologistic.addboot!</code></a></li><li><a href="#Autologistic.addboot!-Union{Tuple{T}, Tuple{ALfit, Vector{T}}} where T&lt;:(NamedTuple{(:sample, :estimate, :convergence)})"><code>Autologistic.addboot!</code></a></li><li><a href="#Autologistic.centeringterms"><code>Autologistic.centeringterms</code></a></li><li><a href="#Autologistic.conditionalprobabilities-Tuple{AbstractAutologisticModel}"><code>Autologistic.conditionalprobabilities</code></a></li><li><a href="#Autologistic.datasets-Tuple{String}"><code>Autologistic.datasets</code></a></li><li><a href="#Autologistic.fit_ml!-Tuple{AbstractAutologisticModel}"><code>Autologistic.fit_ml!</code></a></li><li><a href="#Autologistic.fit_pl!-Tuple{AbstractAutologisticModel}"><code>Autologistic.fit_pl!</code></a></li><li><a href="#Autologistic.fullPMF-Tuple{AbstractAutologisticModel}"><code>Autologistic.fullPMF</code></a></li><li><a href="#Autologistic.getpairwiseparameters-Tuple{AbstractAutologisticModel}"><code>Autologistic.getpairwiseparameters</code></a></li><li><a href="#Autologistic.getparameters-Tuple{AbstractAutologisticModel}"><code>Autologistic.getparameters</code></a></li><li><a href="#Autologistic.getunaryparameters-Tuple{AbstractAutologisticModel}"><code>Autologistic.getunaryparameters</code></a></li><li><a href="#Autologistic.loglikelihood-Tuple{AbstractAutologisticModel}"><code>Autologistic.loglikelihood</code></a></li><li><a href="#Autologistic.makebool"><code>Autologistic.makebool</code></a></li><li><a href="#Autologistic.makecoded-Tuple{VecOrMat, Tuple{Real, Real}}"><code>Autologistic.makecoded</code></a></li><li><a href="#Autologistic.makecoded-Tuple{AbstractAutologisticModel}"><code>Autologistic.makecoded</code></a></li><li><a href="#Autologistic.makegrid4"><code>Autologistic.makegrid4</code></a></li><li><a href="#Autologistic.makegrid8"><code>Autologistic.makegrid8</code></a></li><li><a href="#Autologistic.makespatialgraph-Union{Tuple{C}, Tuple{C, Real}} where C&lt;:(Union{Array{Tuple{T, T}, 1}, Array{Tuple{T, T, T}, 1}} where T&lt;:Real)"><code>Autologistic.makespatialgraph</code></a></li><li><a href="#Autologistic.marginalprobabilities-Tuple{AbstractAutologisticModel}"><code>Autologistic.marginalprobabilities</code></a></li><li><a href="#Autologistic.negpotential-Tuple{AbstractAutologisticModel}"><code>Autologistic.negpotential</code></a></li><li><a href="#Autologistic.oneboot-Tuple{AbstractAutologisticModel, Vector{Float64}}"><code>Autologistic.oneboot</code></a></li><li><a href="#Autologistic.oneboot-Tuple{AbstractAutologisticModel}"><code>Autologistic.oneboot</code></a></li><li><a href="#Autologistic.pseudolikelihood-Tuple{AbstractAutologisticModel}"><code>Autologistic.pseudolikelihood</code></a></li><li><a href="#Autologistic.setpairwiseparameters!-Tuple{AbstractAutologisticModel, Vector{Float64}}"><code>Autologistic.setpairwiseparameters!</code></a></li><li><a href="#Autologistic.setparameters!-Tuple{AbstractAutologisticModel, Vector{Float64}}"><code>Autologistic.setparameters!</code></a></li><li><a href="#Autologistic.setunaryparameters!-Tuple{AbstractAutologisticModel, Vector{Float64}}"><code>Autologistic.setunaryparameters!</code></a></li><li><a href="#StatsBase.sample"><code>StatsBase.sample</code></a></li></ul><h2 id="Types-and-Constructors"><a class="docs-heading-anchor" href="#Types-and-Constructors">Types and Constructors</a><a id="Types-and-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Autologistic.ALRsimple" href="#Autologistic.ALRsimple"><code>Autologistic.ALRsimple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ALRsimple</code></pre><p>An autologistic regression model with &quot;simple smoothing&quot;:  the unary parameter is of type <code>LinPredUnary</code>, and the pairwise parameter is of type <code>SimplePairwise</code>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ALRsimple(unary::LinPredUnary, pairwise::SimplePairwise;
    Y::Union{Nothing,&lt;:VecOrMat} = nothing,
    centering::CenteringKinds = none, 
    coding::Tuple{Real,Real} = (-1,1),
    labels::Tuple{String,String} = (&quot;low&quot;,&quot;high&quot;), 
    coordinates::SpatialCoordinates = [(0.0,0.0) for i=1:size(unary,1)]
)
ALRsimple(graph::SimpleGraph{Int}, X::Float2D3D; 
    Y::VecOrMat = Array{Bool,2}(undef,nv(graph),size(X,3)),
    β::Vector{Float64} = zeros(size(X,2)),
    λ::Float64 = 0.0, 
    centering::CenteringKinds = none, 
    coding::Tuple{Real,Real} = (-1,1),
    labels::Tuple{String,String} = (&quot;low&quot;,&quot;high&quot;),
    coordinates::SpatialCoordinates = [(0.0,0.0) for i=1:nv(graph)]
)</code></pre><p><strong>Arguments</strong></p><ul><li><code>Y</code>: the array of dichotomous responses.  Any array with 2 unique values will work. If the array has only one unique value, it must equal one of the coding values. The  supplied object will be internally represented as a Boolean array.</li><li><code>β</code>: the regression coefficients.</li><li><code>λ</code>: the association parameter.</li><li><code>centering</code>: controls what form of centering to use.</li><li><code>coding</code>: determines the numeric coding of the dichotomous responses. </li><li><code>labels</code>: a 2-tuple of text labels describing the meaning of <code>Y</code>. The first element is the label corresponding to the lower coding value.</li><li><code>coordinates</code>: an array of 2- or 3-tuples giving spatial coordinates of each vertex in the graph. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs
julia&gt; X = rand(10,3);            #-predictors
julia&gt; Y = rand([-2, 3], 10);     #-responses
julia&gt; g = Graph(10,20);          #-graph
julia&gt; u = LinPredUnary(X);
julia&gt; p = SimplePairwise(g);
julia&gt; model1 = ALRsimple(u, p, Y=Y);
julia&gt; model2 = ALRsimple(g, X, Y=Y);
julia&gt; all([getfield(model1, fn)==getfield(model2, fn) for fn in fieldnames(ALRsimple)])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/ALRsimple_type.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.ALfit" href="#Autologistic.ALfit"><code>Autologistic.ALfit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ALfit</code></pre><p>A type to hold estimation output for autologistic models.  Fitting functions return an  object of this type.</p><p>Depending on the fitting method, some fields might not be set.  Fields that are not used are set to <code>nothing</code> or to zero-dimensional arrays.  The fields are:</p><ul><li><code>estimate</code>: A vector of parameter estimates.</li><li><code>se</code>: A vector of standard errors for the estimates.</li><li><code>pvalues</code>: A vector of p-values for testing the null hypothesis that the parameters equal zero (one-at-a time hypothesis tests).</li><li><code>CIs</code>: A vector of 95% confidence intervals for the parameters (a vector of 2-tuples).</li><li><code>optim</code>: the output of the call to <code>optimize</code> used to get the estimates.</li><li><code>Hinv</code> (used by <code>fit_ml!</code>): The inverse of the Hessian matrix of the objective function,  evaluated at the estimate.</li><li><code>nboot</code> (<code>fit_pl!</code>): number of bootstrap samples to use for error estimation.</li><li><code>kwargs</code> (<code>fit_pl!</code>): holds extra keyword arguments passed in the call to the fitting function.</li><li><code>bootsamples</code> (<code>fit_pl!</code>): the bootstrap samples.</li><li><code>bootestimates</code> (<code>fit_pl!</code>): the bootstrap parameter estimates.</li><li><code>convergence</code>: either a Boolean indicating optimization convergence ( for <code>fit_ml!</code>), or a vector of such values for the optimizations done to estimate bootstrap replicates.</li></ul><p>The empty constructor <code>ALfit()</code> will initialize an object with all fields empty, so the needed fields can be filled afterwards.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/ALfit_type.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.ALfull" href="#Autologistic.ALfull"><code>Autologistic.ALfull</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ALfull</code></pre><p>An autologistic model with a <code>FullUnary</code> unary parameter type and a <code>FullPairwise</code> pairwise parameter type.   This model has the maximum number of unary parameters  (one parameter per variable per observation), and an association matrix with one parameter per edge in the graph.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ALfull(unary::FullUnary, pairwise::FullPairwise; 
    Y::Union{Nothing,&lt;:VecOrMat}=nothing, 
    centering::CenteringKinds=none, 
    coding::Tuple{Real,Real}=(-1,1),
    labels::Tuple{String,String}=(&quot;low&quot;,&quot;high&quot;), 
    coordinates::SpatialCoordinates=[(0.0,0.0) for i=1:size(unary,1)]
)
ALfull(graph::SimpleGraph{Int}, alpha::Float1D2D, lambda::Vector{Float64}; 
    Y::VecOrMat=Array{Bool,2}(undef,nv(graph),size(alpha,2)), 
    centering::CenteringKinds=none, 
    coding::Tuple{Real,Real}=(-1,1),
    labels::Tuple{String,String}=(&quot;low&quot;,&quot;high&quot;),
    coordinates::SpatialCoordinates=[(0.0,0.0) for i=1:nv(graph)]
)
ALfull(graph::SimpleGraph{Int}, count::Int=1; 
    Y::VecOrMat=Array{Bool,2}(undef,nv(graph),count), 
    centering::CenteringKinds=none, 
    coding::Tuple{Real,Real}=(-1,1),
    labels::Tuple{String,String}=(&quot;low&quot;,&quot;high&quot;),
    coordinates::SpatialCoordinates=[(0.0,0.0) for i=1:nv(graph)]
)</code></pre><p><strong>Arguments</strong></p><ul><li><code>Y</code>: the array of dichotomous responses.  Any array with 2 unique values will work. If the array has only one unique value, it must equal one of th coding values. The  supplied object will be internally represented as a Boolean array.</li><li><code>centering</code>: controls what form of centering to use.</li><li><code>coding</code>: determines the numeric coding of the dichotomous responses. </li><li><code>labels</code>: a 2-tuple of text labels describing the meaning of <code>Y</code>. The first element is the label corresponding to the lower coding value.</li><li><code>coordinates</code>: an array of 2- or 3-tuples giving spatial coordinates of each vertex in the graph. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Graph(10, 20);          #-graph (20 edges)
julia&gt; alpha = zeros(10, 4);       #-unary parameter values
julia&gt; lambda = rand(20);          #-pairwise parameter values
julia&gt; Y = rand([0, 1], 10, 4);    #-responses
julia&gt; u = FullUnary(alpha);
julia&gt; p = FullPairwise(g, 4);
julia&gt; setparameters!(p, lambda);
julia&gt; model1 = ALfull(u, p, Y=Y);
julia&gt; model2 = ALfull(g, alpha, lambda, Y=Y);
julia&gt; model3 = ALfull(g, 4, Y=Y);
julia&gt; setparameters!(model3, [alpha[:]; lambda]);
julia&gt; all([getfield(model1, fn)==getfield(model2, fn)==getfield(model3, fn)
            for fn in fieldnames(ALfull)])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/ALfull_type.jl#L1-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.ALsimple" href="#Autologistic.ALsimple"><code>Autologistic.ALsimple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ALsimple</code></pre><p>An autologistic model with a <code>FullUnary</code> unary parameter type and a <code>SimplePairwise</code> pairwise parameter type.   This model has the maximum number of unary parameters  (one parameter per variable per observation), and a single association parameter.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ALsimple(unary::FullUnary, pairwise::SimplePairwise; 
    Y::Union{Nothing,&lt;:VecOrMat} = nothing, 
    centering::CenteringKinds = none, 
    coding::Tuple{Real,Real} = (-1,1),
    labels::Tuple{String,String} = (&quot;low&quot;,&quot;high&quot;), 
    coordinates::SpatialCoordinates = [(0.0,0.0) for i=1:size(unary,1)]
)
ALsimple(graph::SimpleGraph{Int}, alpha::Float1D2D; 
    Y::VecOrMat = Array{Bool,2}(undef,nv(graph),size(alpha,2)), 
    λ::Float64 = 0.0, 
    centering::CenteringKinds = none, 
    coding::Tuple{Real,Real} = (-1,1),
    labels::Tuple{String,String} = (&quot;low&quot;,&quot;high&quot;),
    coordinates::SpatialCoordinates = [(0.0,0.0) for i=1:nv(graph)]
)
ALsimple(graph::SimpleGraph{Int}, count::Int = 1; 
    Y::VecOrMat = Array{Bool,2}(undef,nv(graph),size(alpha,2)), 
    λ::Float64=0.0, 
    centering::CenteringKinds=none, 
    coding::Tuple{Real,Real}=(-1,1),
    labels::Tuple{String,String}=(&quot;low&quot;,&quot;high&quot;),
    coordinates::SpatialCoordinates=[(0.0,0.0) for i=1:nv(graph)]
)</code></pre><p><strong>Arguments</strong></p><ul><li><code>Y</code>: the array of dichotomous responses.  Any array with 2 unique values will work. If the array has only one unique value, it must equal one of th coding values. The  supplied object will be internally represented as a Boolean array.</li><li><code>λ</code>: the association parameter.</li><li><code>centering</code>: controls what form of centering to use.</li><li><code>coding</code>: determines the numeric coding of the dichotomous responses. </li><li><code>labels</code>: a 2-tuple of text labels describing the meaning of <code>Y</code>. The first element is the label corresponding to the lower coding value.</li><li><code>coordinates</code>: an array of 2- or 3-tuples giving spatial coordinates of each vertex in the graph. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alpha = zeros(10, 4);       #-unary parameter values
julia&gt; Y = rand([0, 1], 10, 4);    #-responses
julia&gt; g = Graph(10, 20);          #-graph
julia&gt; u = FullUnary(alpha);
julia&gt; p = SimplePairwise(g, 4);
julia&gt; model1 = ALsimple(u, p, Y=Y);
julia&gt; model2 = ALsimple(g, alpha, Y=Y);
julia&gt; model3 = ALsimple(g, 4, Y=Y);
julia&gt; all([getfield(model1, fn)==getfield(model2, fn)==getfield(model3, fn)
            for fn in fieldnames(ALsimple)])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/ALsimple_type.jl#L1-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.AbstractAutologisticModel" href="#Autologistic.AbstractAutologisticModel"><code>Autologistic.AbstractAutologisticModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractAutologisticModel</code></pre><p>Abstract type representing autologistic models. All concrete subtypes should have the following fields:</p><ul><li><code>responses::Array{Bool,2}</code> – The binary observations. Rows are for nodes in the    graph, and columns are for independent (vector) observations.  It is a 2D array even if    there is only one observation.</li><li><code>unary&lt;:AbstractUnaryParameter</code> – Specifies the unary part of the model.</li><li><code>pairwise&lt;:AbstractPairwiseParameter</code>  – Specifies the pairwise part of the model    (including the graph).</li><li><code>centering&lt;:CenteringKinds</code> – Specifies the form of centering used, if any.</li><li><code>coding::Tuple{T,T} where T&lt;:Real</code> – Gives the numeric coding of the responses.</li><li><code>labels::Tuple{String,String}</code> – Provides names for the high and low states.</li><li><code>coordinates&lt;:SpatialCoordinates</code> – Provides 2D or 3D coordinates for each vertex in    the graph.</li></ul><p>This type has the following functions defined, considered part of the type&#39;s interface. They cover most operations one will want to perform.  Concrete subtypes should not have to define custom overrides unless more specialized or efficient algorithms exist for the  subtype.</p><ul><li><code>getparameters</code> and <code>setparameters!</code></li><li><code>getunaryparameters</code> and <code>setunaryparameters!</code></li><li><code>getpairwiseparameters</code> and <code>setpairwiseparameters!</code></li><li><code>centeringterms</code></li><li><code>negpotential</code>, <code>pseudolikelihood</code>, and <code>loglikelihood</code></li><li><code>fullPMF</code>, <code>marginalprobabilities</code>, and <code>conditionalprobabilities</code></li><li><code>fit_pl!</code> and <code>fit_ml!</code></li><li><code>sample</code> and <code>oneboot</code></li><li><code>showfields</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = ALsimple(Graph(4,4));
julia&gt; typeof(M)
ALsimple{CenteringKinds,Int64,Nothing}
julia&gt; isa(M, AbstractAutologisticModel)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.AbstractPairwiseParameter" href="#Autologistic.AbstractPairwiseParameter"><code>Autologistic.AbstractPairwiseParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPairwiseParameter</code></pre><p>Abstract type representing the pairwise part of an autologistic regression model.</p><p>All concrete subtypes should have the following fields:</p><ul><li><code>G::SimpleGraph{Int}</code> – The graph for the model.</li><li><code>count::Int</code>  – The number of observations.</li></ul><p>In addition to <code>getindex()</code> and <code>setindex!()</code>, any concrete subtype  <code>P&lt;:AbstractPairwiseParameter</code> should also have the following methods defined:</p><ul><li><code>getparameters(P)</code>, returning a Vector{Float64}</li><li><code>setparameters!(P, newpar::Vector{Float64})</code> for setting parameter values.</li></ul><p>Note that indexing is performance-critical and should be implemented carefully in  subtypes.  </p><p>The intention is that each subtype should implement a different way of parameterizing the association matrix. The way parameters are stored and values computed is up to the subtypes. </p><p>This type inherits from <code>AbstractArray{Float64, 3}</code>.  The third index is to allow for  multiple observations. <code>P[:,:,r]</code> should return the association matrix of the rth observation in an appropriate subtype of AbstractMatrix.  It is not intended that the third  index will be used for range or vector indexing like <code>P[:,:,1:5]</code> (though this may work  due to AbstractArray fallbacks). </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = ALsimple(Graph(4,4));
julia&gt; typeof(M.pairwise)
SimplePairwise
julia&gt; isa(M.pairwise, AbstractPairwiseParameter)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractpairwiseparameter_type.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.AbstractUnaryParameter" href="#Autologistic.AbstractUnaryParameter"><code>Autologistic.AbstractUnaryParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractUnaryParameter</code></pre><p>Abstract type representing the unary part of an autologistic regression model.</p><p>This type inherits from AbstractArray{Float64, 2}. The first dimension is for vertices/variables in the graph, and the second dimension is for observations.  It is two-dimensional even if there is only one observation. </p><p>Implementation details are left to concrete subtypes, and will depend on how the unary terms are parametrized.  Note that indexing is performance-critical.</p><p>Concrete subtypes should implement <code>getparameters</code>, <code>setparameters!</code>, and <code>showfields</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = ALsimple(Graph(4,4));
julia&gt; typeof(M.unary)
FullUnary
julia&gt; isa(M.unary, AbstractUnaryParameter)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractunaryparameter_type.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.CenteringKinds" href="#Autologistic.CenteringKinds"><code>Autologistic.CenteringKinds</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CenteringKinds</code></pre><p>An enumeration to facilitate choosing a form of centering for the model.  Available choices are: </p><ul><li><code>none</code>: no centering (centering adjustment equals zero).</li><li><code>expectation</code>: the centering adjustment is the expected value of the response under the assumption of independence (this is what has been used in the &quot;centered autologistic  model&quot;).</li><li><code>onehalf</code>: a constant value of centering adjustment equal to 0.5 (this produces the &quot;symmetric autologistic model&quot; when used with 0,1 coding).</li></ul><p>The default/recommended model has centering of <code>none</code> with (-1, 1) coding.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; CenteringKinds
Enum CenteringKinds:
none = 0
expectation = 1
onehalf = 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L19-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.FullPairwise" href="#Autologistic.FullPairwise"><code>Autologistic.FullPairwise</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FullPairwise</code></pre><p>A type representing an association matrix with a &quot;saturated&quot; parametrization–one parameter  for each edge in the graph.</p><p>In this type, the association matrix for each observation is a symmetric matrix with the  same pattern of nonzeros as the graph&#39;s adjacency matrix, but with arbitrary values in those locations. The package convention is to provide parameters as a vector of <code>Float64</code>.  So  <code>getparameters</code> and <code>setparameters!</code> use a vector of <code>ne(G)</code> values that correspond to the  nonzero locations in the upper triangle of the adjacency matrix, in the same (lexicographic) order as <code>edges(G)</code>.</p><p>The association matrix is stored as a <code>SparseMatrixCSC{Float64,Int64}</code> in the field Λ.</p><p>This type does not allow for different observations to have different association matricse. So while <code>size</code> returns a 3-dimensional result, the third index is ignored when accessing the array&#39;s elements.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">FullPairwise(G::SimpleGraph, count::Int=1)
FullPairwise(n::Int, count::Int=1)
FullPairwise(λ::Real, G::SimpleGraph)
FullPairwise(λ::Real, G::SimpleGraph, count::Int)
FullPairwise(λ::Vector{Float64}, G::SimpleGraph)</code></pre><p>If provide only a graph, set λ = zeros(nv(G)). If provide only an integer, set λ to zeros and make a totally disconnected graph. If provide a graph and a scalar, convert the scalar to a vector of the right length.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = makegrid4(2,2).G;
julia&gt; λ = [1.0, 2.0, -1.0, -2.0];
julia&gt; p = FullPairwise(λ, g);
julia&gt; typeof(p.Λ)
SparseArrays.SparseMatrixCSC{Float64,Int64}

julia&gt; Matrix(p[:,:])
4×4 Array{Float64,2}:
 0.0   1.0   2.0   0.0
 1.0   0.0   0.0  -1.0
 2.0   0.0   0.0  -2.0
 0.0  -1.0  -2.0   0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/fullpairwise_type.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.FullUnary" href="#Autologistic.FullUnary"><code>Autologistic.FullUnary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FullUnary</code></pre><p>The unary part of an autologistic model, with one parameter per vertex per observation. The type has only a single field, for holding an array of parameters.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">FullUnary(alpha::Array{Float64,1}) 
FullUnary(n::Int)                     #-initializes parameters to zeros
FullUnary(n::Int, m::Int)             #-initializes parameters to zeros</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = FullUnary(5, 3);
julia&gt; u[:,:]
5×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/fullunary_type.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.LinPredUnary" href="#Autologistic.LinPredUnary"><code>Autologistic.LinPredUnary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinPredUnary</code></pre><p>The unary part of an autologistic model, parametrized as a regression linear predictor. Its fields are <code>X</code>, an n-by-p-by-m matrix (n obs, p predictors, m observations), and <code>β</code>, a p-vector of parameters (the same for all observations).</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">LinPredUnary(X::Matrix{Float64}, β::Vector{Float64})
LinPredUnary(X::Matrix{Float64})
LinPredUnary(X::Array{Float64, 3})
LinPredUnary(n::Int,p::Int)
LinPredUnary(n::Int,p::Int,m::Int)</code></pre><p>Any quantities not provided in the constructors are initialized to zeros.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = LinPredUnary(ones(5,3,2), [1.0, 2.0, 3.0]);
julia&gt; u[:,:]
5×2 Array{Float64,2}:
 6.0  6.0
 6.0  6.0
 6.0  6.0
 6.0  6.0
 6.0  6.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/linpredunary_type.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.SamplingMethods" href="#Autologistic.SamplingMethods"><code>Autologistic.SamplingMethods</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SamplingMethods</code></pre><p>An enumeration to facilitate choosing a method for random sampling from autologistic models. Available choices are:</p><ul><li><code>Gibbs</code>:  Gibbs sampling.</li><li><code>perfect_bounding_chain</code>: Perfect sampling, using a bounding chain algorithm.</li><li><code>perfect_reuse_samples</code>: Perfect sampling. CFTP implemented by reusing random numbers.</li><li><code>perfect_reuse_seeds</code>: Perfect sampling. CFTP implemented by reusing RNG seeds.</li><li><code>perfect_read_once</code>: Perfect sampling. Read-once CFTP implementation.</li></ul><p>All of the perfect sampling methods are implementations of coupling from the past (CFTP). <code>perfect_bounding_chain</code> uses a bounding chain approach that holds even when Λ contains negative elements; the other three options rely on a monotonicity argument that requires Λ to have only positive elements (though they should work similar to Gibbs sampling in that case).</p><p>Different perfect sampling implementations might work best for different models, and parameter settings exist where perfect sampling coalescence might take a prohibitively long time.  For these reasons, Gibbs sampling is the default in <code>sample</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SamplingMethods
Enum SamplingMethods:
Gibbs = 0
perfect_reuse_samples = 1
perfect_reuse_seeds = 2
perfect_read_once = 3
perfect_bounding_chain = 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L45-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.SimplePairwise" href="#Autologistic.SimplePairwise"><code>Autologistic.SimplePairwise</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimplePairwise</code></pre><p>Pairwise association matrix, parametrized as a scalar parameter times the adjacency matrix.</p><p><strong>Constructors</strong></p><p>SimplePairwise(G::SimpleGraph, count::Int=1) SimplePairwise(n::Int, count::Int=1) SimplePairwise(λ::Real, G::SimpleGraph) SimplePairwise(λ::Real, G::SimpleGraph, count::Int)</p><p>If provide only a graph, set λ = 0. If provide only an integer, set λ = 0 and make a totally disconnected graph. If provide a graph and a scalar, convert the scalar to a length-1 vector.</p><p>Every observation must have the same association matrix in this case. So while we internally treat it like an n-by-n-by-m matrix, just return a 2D n-by-n matrix to the user. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = makegrid4(2,2).G;
julia&gt; λ = 1.0;
julia&gt; p = SimplePairwise(λ, g, 4);    #-4 observations
julia&gt; size(p)
(4, 4, 4)

julia&gt; Matrix(p[:,:,:])
4×4 Array{Float64,2}:
 0.0  1.0  1.0  0.0
 1.0  0.0  0.0  1.0
 1.0  0.0  0.0  1.0
 0.0  1.0  1.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/simplepairwise_type.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.Float1D2D" href="#Autologistic.Float1D2D"><code>Autologistic.Float1D2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for <code>Union{Array{Float64,1},Array{Float64,2}}</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.Float2D3D" href="#Autologistic.Float2D3D"><code>Autologistic.Float2D3D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for <code>Union{Array{Float64,2},Array{Float64,3}}</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.SpatialCoordinates" href="#Autologistic.SpatialCoordinates"><code>Autologistic.SpatialCoordinates</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for <code>Union{Array{NTuple{2,T},1},Array{NTuple{3,T},1}} where T&lt;:Real</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.VecOrMat" href="#Autologistic.VecOrMat"><code>Autologistic.VecOrMat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for <code>Union{Array{T,1}, Array{T,2}} where T</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L2">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Autologistic.addboot!-Tuple{ALfit, Array{Float64, 3}, Matrix{Float64}, Vector{Bool}}" href="#Autologistic.addboot!-Tuple{ALfit, Array{Float64, 3}, Matrix{Float64}, Vector{Bool}}"><code>Autologistic.addboot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addboot!(fit::ALfit, bootsamples::Array{Float64,3}, 
         bootestimates::Array{Float64,2}, convergence::Vector{Bool})</code></pre><p>Add parametric bootstrap information in arrays <code>bootsamples</code>, <code>bootestimates</code>, and <code>convergence</code> to model fitting information <code>fit</code>.  If <code>fit</code> already contains bootstrap data, the new data is appended to the existing data, and statistics are recomputed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random;
julia&gt; Random.seed!(1234);
julia&gt; G = makegrid4(4,3).G;
julia&gt; Y=[[fill(-1,4); fill(1,8)] [fill(-1,3); fill(1,9)] [fill(-1,5); fill(1,7)]];
julia&gt; model = ALRsimple(G, ones(12,1,3), Y=Y);
julia&gt; fit = fit_pl!(model, start=[-0.4, 1.1]);
julia&gt; samps = zeros(12,3,10);
julia&gt; ests = zeros(2,10);
julia&gt; convs = fill(false, 10);
julia&gt; for i = 1:10
           temp = oneboot(model, start=[-0.4, 1.1])
           samps[:,:,i] = temp.sample
           ests[:,i] = temp.estimate
           convs[i] = temp.convergence
       end
julia&gt; addboot!(fit, samps, ests, convs)
julia&gt; summary(fit)
name          est     se      95% CI
parameter 1   -0.39   0.442      (-1.09, 0.263)
parameter 2    1.1    0.279   (-0.00664, 0.84)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/ALfit_type.jl#L211-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.addboot!-Union{Tuple{T}, Tuple{ALfit, Vector{T}}} where T&lt;:(NamedTuple{(:sample, :estimate, :convergence)})" href="#Autologistic.addboot!-Union{Tuple{T}, Tuple{ALfit, Vector{T}}} where T&lt;:(NamedTuple{(:sample, :estimate, :convergence)})"><code>Autologistic.addboot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addboot!(fit::ALfit, bootresults::Array{T,1}) where 
    T &lt;: NamedTuple{(:sample, :estimate, :convergence)}</code></pre><p>An <code>addboot!</code> method taking bootstrap data as an array of named tuples. Tuples are of the form produced by <code>oneboot</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt;     using Random;
julia&gt;     Random.seed!(1234);
julia&gt;     G = makegrid4(4,3).G;
julia&gt;     Y=[[fill(-1,4); fill(1,8)] [fill(-1,3); fill(1,9)] [fill(-1,5); fill(1,7)]];
julia&gt;     model = ALRsimple(G, ones(12,1,3), Y=Y);
julia&gt;     fit = fit_pl!(model, start=[-0.4, 1.1]);
julia&gt;     boots = [oneboot(model, start=[-0.4, 1.1]) for i = 1:10];
julia&gt;     addboot!(fit, boots)
julia&gt;     summary(fit)
name          est     se      95% CI
parameter 1   -0.39   0.442      (-1.09, 0.263)
parameter 2    1.1    0.279   (-0.00664, 0.84)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/ALfit_type.jl#L276-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.centeringterms" href="#Autologistic.centeringterms"><code>Autologistic.centeringterms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centeringterms(M::AbstractAutologisticModel, kind::Union{Nothing,CenteringKinds}=nothing)</code></pre><p>Returns an <code>Array{Float64,2}</code> of the same dimension as <code>M.unary</code>, giving the centering adjustments for autologistic model <code>M</code>. <code>centeringterms(M,kind)</code> returns the centering adjustment that would be used if centering were of type <code>kind</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = makegrid8(2,2).G;
julia&gt; X = [ones(4) [-2; -1; 1; 2]];
julia&gt; M1 = ALRsimple(G, X, β=[-1.0, 2.0]);                 #-No centering (default)
julia&gt; M2 = ALRsimple(G, X, β=[-1.0, 2.0], centering=expectation);  #-Centered model
julia&gt; [centeringterms(M1) centeringterms(M2) centeringterms(M1, onehalf)]
4×3 Array{Float64,2}:
 0.0  -0.999909  0.5
 0.0  -0.995055  0.5
 0.0   0.761594  0.5
 0.0   0.995055  0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L123-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.conditionalprobabilities-Tuple{AbstractAutologisticModel}" href="#Autologistic.conditionalprobabilities-Tuple{AbstractAutologisticModel}"><code>Autologistic.conditionalprobabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conditionalprobabilities(M::AbstractAutologisticModel; vertices=1:size(M.unary)[1], 
                         indices=1:size(M.unary,2))</code></pre><p>Compute the conditional probability that variables in autologistic model <code>M</code> take the high state, given the current values of all of their neighbors. If <code>vertices</code> or <code>indices</code> are provided, the results are only computed for the desired variables &amp; observations.   Otherwise results are computed for all variables and observations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = [ones(9) zeros(9)];
julia&gt; G = makegrid4(3,3).G;
julia&gt; model = ALsimple(G, ones(9,2), Y=Y, λ=0.5);    #-Variables on a 3×3 grid, 2 obs.
julia&gt; conditionalprobabilities(model, vertices=5)    #-Cond. probs. of center vertex.
1×2 Array{Float64,2}:
 0.997527  0.119203

julia&gt; conditionalprobabilities(model, indices=2)     #-Cond probs, 2nd observation.
9×1 Array{Float64,2}:
 0.5
 0.26894142136999516
 0.5
 0.26894142136999516
 0.11920292202211756
 0.26894142136999516
 0.5
 0.26894142136999516
 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L654-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.datasets-Tuple{String}" href="#Autologistic.datasets-Tuple{String}"><code>Autologistic.datasets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`Autologistic.datasets(name::String)`</code></pre><p>Open data sets for demonstrations of Autologistic regression. Returns the data set as a <code>DataFrame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L308-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.fit_ml!-Tuple{AbstractAutologisticModel}" href="#Autologistic.fit_ml!-Tuple{AbstractAutologisticModel}"><code>Autologistic.fit_ml!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_ml!(M::AbstractAutologisticModel;
    start=zeros(length(getparameters(M))),
    verbose::Bool=false,
    force::Bool=false,
    kwargs...
)</code></pre><p>Fit autologistic model <code>M</code> using maximum likelihood. Will fail for models with more than  20 vertices, unless <code>force=true</code>.  Use <code>fit_pl!</code> for larger models.</p><p><strong>Arguments</strong></p><ul><li><code>start</code>: initial value to use for optimization.</li><li><code>verbose</code>: should progress information be printed to the console?</li><li><code>force</code>: set to <code>true</code> to force computation of the likelihood for large models.</li><li><code>kwargs...</code> extra keyword arguments that are passed on to <code>optimize()</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = makegrid4(4,3).G;
julia&gt; model = ALRsimple(G, ones(12,1), Y=[fill(-1,4); fill(1,8)]);
julia&gt; mle = fit_ml!(model);
julia&gt; summary(mle)
name          est      se      p-value   95% CI
parameter 1   0.0791   0.163   0.628       (-0.241, 0.399)
parameter 2   0.425    0.218   0.0511    (-0.00208, 0.852)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L507-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.fit_pl!-Tuple{AbstractAutologisticModel}" href="#Autologistic.fit_pl!-Tuple{AbstractAutologisticModel}"><code>Autologistic.fit_pl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_pl!(M::AbstractAutologisticModel;
    start=zeros(length(getparameters(M))), 
    verbose::Bool=false,
    nboot::Int = 0,
    kwargs...)</code></pre><p>Fit autologistic model <code>M</code> using maximum pseudolikelihood. </p><p><strong>Arguments</strong></p><ul><li><code>start</code>: initial value to use for optimization.</li><li><code>verbose</code>: should progress information be printed to the console?</li><li><code>nboot</code>: number of samples to use for parametric bootstrap error estimation. If <code>nboot=0</code> (the default), no bootstrap is run.</li><li><code>kwargs...</code> extra keyword arguments that are passed on to <code>optimize()</code> or <code>sample()</code>, as appropriate.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y=[[fill(-1,4); fill(1,8)] [fill(-1,3); fill(1,9)] [fill(-1,5); fill(1,7)]];
julia&gt; model = ALRsimple(makegrid4(4,3).G, ones(12,1,3), Y=Y);
julia&gt; fit = fit_pl!(model, start=[-0.4, 1.1]);
julia&gt; summary(fit)
name          est     se   p-value   95% CI
parameter 1   -0.39
parameter 2    1.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L271-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.fullPMF-Tuple{AbstractAutologisticModel}" href="#Autologistic.fullPMF-Tuple{AbstractAutologisticModel}"><code>Autologistic.fullPMF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fullPMF(M::AbstractAutologisticModel; 
    indices=1:size(M.unary,2), 
    force::Bool=false
)</code></pre><p>Compute the PMF of an AbstractAutologisticModel, and return a <code>NamedTuple</code> <code>(:table, :partition)</code>.</p><p>For an AbstractAutologisticModel with <span>$n$</span> variables and <span>$m$</span> observations, <code>:table</code> is a <span>$2^n×(n+1)×m$</span> array of <code>Float64</code>. Each page of the 3D array holds a probability table for  an observation.  Each row of the table holds a specific configuration of the responses, with the corresponding probability in the last column.  In the <span>$m=1$</span> case,  <code>:table</code> is a 2D  array.</p><p>Output <code>:partition</code> is a vector of normalizing constant (a.k.a. partition function) values. In the <span>$m=1$</span> case, it is a scalar <code>Float64</code>.</p><p><strong>Arguments</strong></p><ul><li><code>indices</code>: indices of specific observations from which to obtain the output. By  default, all observations are used.</li><li><code>force</code>: calling the function with <span>$n&gt;20$</span> will throw an error unless  <code>force=true</code>. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = ALRsimple(Graph(3,0),ones(3,1));
julia&gt; pmf = fullPMF(M);
julia&gt; pmf.table
8×4 Array{Float64,2}:
 -1.0  -1.0  -1.0  0.125
 -1.0  -1.0   1.0  0.125
 -1.0   1.0  -1.0  0.125
 -1.0   1.0   1.0  0.125
  1.0  -1.0  -1.0  0.125
  1.0  -1.0   1.0  0.125
  1.0   1.0  -1.0  0.125
  1.0   1.0   1.0  0.125
julia&gt; pmf.partition
 8.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L402-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.getpairwiseparameters-Tuple{AbstractAutologisticModel}" href="#Autologistic.getpairwiseparameters-Tuple{AbstractAutologisticModel}"><code>Autologistic.getpairwiseparameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getpairwiseparameters(M::AbstractAutologisticModel)</code></pre><p>Extracts the pairwise parameters from an autologistic model. Parameters are always returned as an <code>Array{Float64,1}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.getparameters-Tuple{AbstractAutologisticModel}" href="#Autologistic.getparameters-Tuple{AbstractAutologisticModel}"><code>Autologistic.getparameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getparameters(x)</code></pre><p>A generic function for extracting the parameters from an autologistic model, a unary term, or a pairwise term.  Parameters are always returned as an <code>Array{Float64,1}</code>.  If  <code>typeof(x) &lt;: AbstractAutologisticModel</code>, the returned vector is partitioned with the unary parameters first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.getunaryparameters-Tuple{AbstractAutologisticModel}" href="#Autologistic.getunaryparameters-Tuple{AbstractAutologisticModel}"><code>Autologistic.getunaryparameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getunaryparameters(M::AbstractAutologisticModel)</code></pre><p>Extracts the unary parameters from an autologistic model. Parameters are always returned as an <code>Array{Float64,1}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.loglikelihood-Tuple{AbstractAutologisticModel}" href="#Autologistic.loglikelihood-Tuple{AbstractAutologisticModel}"><code>Autologistic.loglikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loglikelihood(M::AbstractAutologisticModel; 
    force::Bool=false
)</code></pre><p>Compute the natural logarithm of the likelihood for autologistic model <code>M</code>.  This will throw an error for models with more than 20 vertices, unless <code>force=true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = ALRsimple(makegrid4(2,2)[1], ones(4,2,3), centering = expectation,
                         coding = (0,1), Y = repeat([true, true, false, false],1,3));
julia&gt; setparameters!(model, [1.0, 1.0, 1.0]);
julia&gt; loglikelihood(model)
-11.86986109487605</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L480-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.makebool" href="#Autologistic.makebool"><code>Autologistic.makebool</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makebool(v::VecOrMat, vals=nothing)</code></pre><p>Makes a 2D array of Booleans out of a 1- or 2-D input.  The 2nd argument <code>vals</code> optionally can be a 2-tuple (low, high) specifying the two possible values in <code>v</code> (useful for the case where all elements of <code>v</code> take one value or the other).</p><ul><li>If <code>v</code> has more than 2 unique values, throws an error.</li><li>If <code>v</code> has exactly 2 unique values, use those to set the coding (ignore <code>vals</code>).</li><li>If <code>v</code> has 1 unique value, use <code>vals</code> to determine if it&#39;s the high or low value (throw an error if the single value isn&#39;t in <code>vals</code>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; makebool([1.0 2.0; 1.0 2.0])
2×2 Array{Bool,2}:
 false  true
 false  true

julia&gt; makebool([&quot;yes&quot;, &quot;no&quot;, &quot;no&quot;])
3×1 Array{Bool,2}:
  true
 false
 false

julia&gt; [makebool([1, 1, 1], (-1,1)) makebool([1, 1, 1], (1, 2))]
3×2 Array{Bool,2}:
 true  false
 true  false
 true  false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L81-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.makecoded-Tuple{AbstractAutologisticModel}" href="#Autologistic.makecoded-Tuple{AbstractAutologisticModel}"><code>Autologistic.makecoded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makecoded(M::AbstractAutologisticModel)</code></pre><p>A convenience method for <code>makecoded(M.responses, M.coding)</code>.  Use it to retrieve a model&#39;s responses in coded form.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = ALRsimple(Graph(4,3), rand(4,2), Y=[true, false, false, true], coding=(-1,1));
julia&gt; makecoded(M)
4×1 Array{Float64,2}:
  1.0
 -1.0
 -1.0
  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L863-L879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.makecoded-Tuple{VecOrMat, Tuple{Real, Real}}" href="#Autologistic.makecoded-Tuple{VecOrMat, Tuple{Real, Real}}"><code>Autologistic.makecoded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makecoded(b::VecOrMat, coding::Tuple{Real,Real})</code></pre><p>Convert Boolean responses into coded values.  The first argument is boolean. Returns a 2D array of Float64.  </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; makecoded([true, false, false, true], (-1, 1))
4×1 Array{Float64,2}:
  1.0
 -1.0
 -1.0
  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L140-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.makegrid4" href="#Autologistic.makegrid4"><code>Autologistic.makegrid4</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makegrid4(r::Int, c::Int, xlim::Tuple{Real,Real}=(0.0,1.0), 
          ylim::Tuple{Real,Real}=(0.0,1.0))</code></pre><p>Returns a named tuple <code>(:G, :locs)</code>, where <code>:G</code> is a graph, and <code>:locs</code> is an array of  numeric tuples.  Vertices of <code>:G</code> are laid out in a rectangular, 4-connected grid with  <code>r</code> rows and <code>c</code> columns.  The tuples in <code>:locs</code> contain the spatial coordinates of each vertex.  Optional arguments <code>xlim</code> and <code>ylim</code> determine the bounds of the rectangular  layout.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; out4 = makegrid4(11, 21, (-1,1), (-10,10));
julia&gt; nv(out4.G) == 11*21                  #231
true
julia&gt; ne(out4.G) == 11*20 + 21*10          #430
true
julia&gt; out4.locs[11*10 + 6] == (0.0, 0.0)   #location of center vertex.
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L173-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.makegrid8" href="#Autologistic.makegrid8"><code>Autologistic.makegrid8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makegrid8(r::Int, c::Int, xlim::Tuple{Real,Real}=(0.0,1.0), 
          ylim::Tuple{Real,Real}=(0.0,1.0))</code></pre><p>Returns a named tuple <code>(:G, :locs)</code>, where <code>:G</code> is a graph, and <code>:locs</code> is an array of  numeric tuples.  Vertices of <code>:G</code> are laid out in a rectangular, 8-connected grid with  <code>r</code> rows and <code>c</code> columns.  The tuples in <code>:locs</code> contain the spatial coordinates of each vertex.  Optional arguments <code>xlim</code> and <code>ylim</code> determine the bounds of the rectangular  layout.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; out8 = makegrid8(11, 21, (-1,1), (-10,10));
julia&gt; nv(out8.G) == 11*21                      #231
true
julia&gt; ne(out8.G) == 11*20 + 21*10 + 2*20*10    #830
true
julia&gt; out8.locs[11*10 + 6] == (0.0, 0.0)       #location of center vertex.
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L224-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.makespatialgraph-Union{Tuple{C}, Tuple{C, Real}} where C&lt;:(Union{Array{Tuple{T, T}, 1}, Array{Tuple{T, T, T}, 1}} where T&lt;:Real)" href="#Autologistic.makespatialgraph-Union{Tuple{C}, Tuple{C, Real}} where C&lt;:(Union{Array{Tuple{T, T}, 1}, Array{Tuple{T, T, T}, 1}} where T&lt;:Real)"><code>Autologistic.makespatialgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makespatialgraph(coords::C, δ::Real) where C&lt;:SpatialCoordinates</code></pre><p>Returns a named tuple <code>(:G, :locs)</code>, where <code>:G</code> is a graph, and <code>:locs</code> is an array of  numeric tuples.  Each element of <code>coords</code> is a 2- or 3-tuple of spatial coordinates, and this argument is returned unchanged as <code>:locs</code>.  The graph <code>:G</code> has <code>length(coords)</code> vertices, with edges connecting every pair of vertices within Euclidean distance <code>δ</code> of each other. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = [(Float64(i), Float64(j)) for i = 1:5 for j = 1:5];
julia&gt; out = makespatialgraph(c, sqrt(2));
julia&gt; out.G
{25, 72} undirected simple Int64 graph

julia&gt; length(out.locs)
25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/common.jl#L271-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.marginalprobabilities-Tuple{AbstractAutologisticModel}" href="#Autologistic.marginalprobabilities-Tuple{AbstractAutologisticModel}"><code>Autologistic.marginalprobabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginalprobabilities(M::AbstractAutologisticModel;
    indices=1:size(M.unary,2), 
    force::Bool=false
)</code></pre><p>Compute the marginal probability that variables in autologistic model <code>M</code> takes the high state. For a model with n vertices and m observations, returns an n-by-m array  (or an n-vector if  m==1). The [i,j]th element is the marginal probability of the high state in the ith variable at the jth observation.  </p><p>This function computes the exact marginals. For large models, approximate the marginal  probabilities by sampling, e.g. <code>sample(M, ..., average=true)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>indices</code>: used to return only the probabilities for certain observations.  </li><li><code>force</code>: the function will throw an error for n &gt; 20 unless <code>force=true</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = ALsimple(Graph(3,0), [[-1.0; 0.0; 1.0] [-1.0; 0.0; 1.0]])
julia&gt; marginalprobabilities(M)
3×2 Array{Float64,2}:
 0.119203  0.119203
 0.5       0.5
 0.880797  0.880797</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L595-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.negpotential-Tuple{AbstractAutologisticModel}" href="#Autologistic.negpotential-Tuple{AbstractAutologisticModel}"><code>Autologistic.negpotential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negpotential(M::AbstractAutologisticModel)</code></pre><p>Returns an m-vector of <code>Float64</code> negpotential values, where m is the number of observations found in <code>M.responses</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = ALsimple(makegrid4(3,3).G, ones(9));
julia&gt; f = fullPMF(M);
julia&gt; exp(negpotential(M)[1])/f.partition ≈ exp(loglikelihood(M))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L374-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.oneboot-Tuple{AbstractAutologisticModel, Vector{Float64}}" href="#Autologistic.oneboot-Tuple{AbstractAutologisticModel, Vector{Float64}}"><code>Autologistic.oneboot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneboot(M::AbstractAutologisticModel, params::Vector{Float64};
    start=zeros(length(getparameters(M))),
    verbose::Bool=false,
    kwargs...
)</code></pre><p>Computes one bootstrap replicate using model <code>M</code>, but using parameters <code>params</code> for  generating samples, instead of <code>getparameters(M)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L251-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.oneboot-Tuple{AbstractAutologisticModel}" href="#Autologistic.oneboot-Tuple{AbstractAutologisticModel}"><code>Autologistic.oneboot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneboot(M::AbstractAutologisticModel; 
    start=zeros(length(getparameters(M))),
    verbose::Bool=false,
    kwargs...
)</code></pre><p>Performs one parametric bootstrap replication from autologistic model <code>M</code>: draw a random sample from <code>M</code>, use that sample as the responses, and re-fit the model.  Returns a named tuple <code>(:sample, :estimate, :convergence)</code>, where <code>:sample</code> holds the random sample, <code>:estimate</code> holds the parameter estimates, and <code>:convergence</code> holds a <code>bool</code> indicating whether or not the optimization converged.  The parameters of <code>M</code> remain unchanged by calling <code>oneboot</code>.</p><p><strong>Arguments</strong></p><ul><li><code>start</code>: starting parameter values to use for optimization</li><li><code>verbose</code>: should progress information be written to the console?</li><li><code>kwargs...</code>: extra keyword arguments that are passed to <code>optimize()</code> or <code>sample()</code>, as appropriate.</li></ul><p><strong>Examples</strong></p><p><code>jldoctest julia&gt; G = makegrid4(4,3).G; julia&gt; model = ALRsimple(G, ones(12,1), Y=[fill(-1,4); fill(1,8)]); julia&gt; theboot = oneboot(model, method=Gibbs, burnin=250); julia&gt; fieldnames(typeof(theboot)) (:sample, :estimate, :convergence)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L206-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.pseudolikelihood-Tuple{AbstractAutologisticModel}" href="#Autologistic.pseudolikelihood-Tuple{AbstractAutologisticModel}"><code>Autologistic.pseudolikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pseudolikelihood(M::AbstractAutologisticModel)</code></pre><p>Computes the negative log pseudolikelihood for autologistic model <code>M</code>. Returns a <code>Float64</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = [1.1 2.2
            1.0 2.0
            2.1 1.2
            3.0 0.3];
julia&gt; Y = [0; 0; 1; 0];
julia&gt; M3 = ALRsimple(makegrid4(2,2)[1], cat(X,X,dims=3), Y=cat(Y,Y,dims=2), 
                      β=[-0.5, 1.5], λ=1.25, centering=expectation);
julia&gt; pseudolikelihood(M3)
12.333549445795818</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L162-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.setpairwiseparameters!-Tuple{AbstractAutologisticModel, Vector{Float64}}" href="#Autologistic.setpairwiseparameters!-Tuple{AbstractAutologisticModel, Vector{Float64}}"><code>Autologistic.setpairwiseparameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setpairwiseparameters!(M::AbstractAutologisticModel, newpars::Vector{Float64})</code></pre><p>Sets the pairwise parameters of autologistic model <code>M</code> to the values in <code>newpars</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.setparameters!-Tuple{AbstractAutologisticModel, Vector{Float64}}" href="#Autologistic.setparameters!-Tuple{AbstractAutologisticModel, Vector{Float64}}"><code>Autologistic.setparameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setparameters!(x, newpars::Vector{Float64})</code></pre><p>A generic function for setting the parameter values of an autologistic model, a unary term, or a pairwise term.  Parameters are always passed as an <code>Array{Float64,1}</code>.  If  <code>typeof(x) &lt;: AbstractAutologisticModel</code>, the <code>newpars</code> is assumed partitioned with the unary parameters first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L71-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Autologistic.setunaryparameters!-Tuple{AbstractAutologisticModel, Vector{Float64}}" href="#Autologistic.setunaryparameters!-Tuple{AbstractAutologisticModel, Vector{Float64}}"><code>Autologistic.setunaryparameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setunaryparameters!(M::AbstractAutologisticModel, newpars::Vector{Float64})</code></pre><p>Sets the unary parameters of autologistic model <code>M</code> to the values in <code>newpars</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(M::AbstractAutologisticModel, k::Int = 1;
    method::SamplingMethods = Gibbs,
    indices = 1:size(M.unary,2), 
    average::Bool = false, 
    config = nothing, 
    burnin::Int = 0,
    skip::Int = 0,
    verbose::Bool = false
)</code></pre><p>Draws <code>k</code> random samples from autologistic model <code>M</code>. For a model with <code>n</code> vertices in its graph, the return value is:</p><ul><li>When <code>average=false</code>, an <code>n</code> × <code>length(indices)</code> × <code>k</code> array, with singleton dimensions dropped. This array holds the random samples.</li><li>When <code>average=true</code>, an <code>n</code>  × <code>length(indices)</code> array, with singleton dimensions dropped. This array holds the estimated marginal probabilities of observing the &quot;high&quot; level at  each vertex.</li></ul><p><strong>Arguments</strong></p><ul><li><code>method</code>: a member of the enum <a href="#Autologistic.SamplingMethods"><code>SamplingMethods</code></a>, specifying which sampling method will be used.  The default is Gibbs sampling.  Where feasible, it is recommended  to use one of the perfect sampling alternatives. See <a href="#Autologistic.SamplingMethods"><code>SamplingMethods</code></a> for more.</li><li><code>indices</code>: gives the indices of the observation to use for sampling. If the model has  more than one observation, then <code>k</code> samples are drawn for each observation&#39;s parameter  settings. Use <code>indices</code> to restrict the samples to a subset of observations. </li><li><code>average</code>: controls the form of the output. When <code>average=true</code>, the return value is the  proportion of &quot;high&quot; samples at each vertex. (Note that this is <strong>not</strong> actually the arithmetic average of the samples, unless the coding is (0,1). Rather, it is an estimate of  the probability of getting a &quot;high&quot; outcome.)  When <code>average=false</code>, the full set of samples is returned. </li><li><code>config</code>: allows a starting configuration of the random variables to be provided. Only used if <code>method=Gibbs</code>. Any vector of the correct length, with two unique values, can be  used as <code>config</code>. By default a random configuration is used.</li><li><code>burnin</code>: specifies the number of initial samples to discard from the results.  Only used if <code>method=Gibbs</code>.</li><li><code>skip</code>: specifies how many samples to throw away between returned samples.  Only used  if <code>method=Gibbs</code>. </li><li><code>verbose</code>: controls output to the console.  If <code>true</code>, intermediate information about  sampling progress is printed to the console. Otherwise no output is shown.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = ALsimple(Graph(4,4));
julia&gt; M.coding = (-2,3);
julia&gt; r = sample(M,10);
julia&gt; size(r)
(4, 10)
julia&gt; sort(unique(r))
2-element Array{Float64,1}:
 -2.0
  3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kramsretlow/Autologistic.jl/blob/34c47fd4b3a0eb45e2932012e24bd14f62d91510/src/abstractautologisticmodel_type.jl#L723-L777">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Sunday 13 March 2022 08:41">Sunday 13 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
